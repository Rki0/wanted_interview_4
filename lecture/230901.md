# [자료구조 | 기초]Hash Table(Hash Map)

## Hash Table에 대해서 설명해주세요. 동작 원리를 설명해주세요.

- 검색, 삽입, 삭제 작업에 효율적인 자료구조
- 평균 O(1)의 시간 복잡도로 key-value pair를 저장하고 검색.
- key는 고유해야하며, 중복되는 key가 있으면 먼저 있던 key와 value를 대체한다.
- 저장 순서(index)를 보장하지 않으므로, 순서에 의존적인 작업에는 적합하지 않다.

- key-value pair를 보통 Entry라고 표현한다.
- Hash Function을 사용해서 저장한다.
- 입력된 key를 table 크기에 적합한 인덱스 값으로 변환하는 것이 목적이다.
- 즉, Hash Function은 key를 입력 받아서 Hash Table 상의 주소값을 반환한다.
- 크기가 10인 Hash Table에서 Hash Function의 출력값은 0 ~ 9가 된다.
- 입력된 key를 Hash Table에 고루 분산시켜 저장할 수 있는 함수가 좋은 Hash Function이다.(균등성)
- 대표적인 방법으로는 나누기 방법(Division Method)가 있다.
- h(x) = M % m
- M은 digest(입력값 x를 해시 처리한 값), m은 table의 크기
- 일반적으로 Hash table의 크기는 2의 멱수에 가깝지 않은 소수를 선택한다. 그러면 균등성이 높아질 가능성이 많아진다.

- 데이터에 빠른 검색, 삽입, 삭제 작업이 필요한 경우
- key-value pair인 데이터를 관리해야되는 상황
- 중복 데이터 검사: key의 유일성을 보장하기 때문에 데이터 중복 검사 및 제거 가능
- 캐싱(Caching): 캐싱용 서버에 key-value pair를 저장할 때, 내부적으로 Hash table 사용.

- 단점
- 두 개 이상의 키가 동일한 해시 값을 가질 경우 충돌이 발생.
- 충돌을 관리하는 많은 방법들이 있지만, 빈번하게 발생하는 경우 성능 저하를 가져올 수 있다.

## 해시 테이블에서 충돌이 발생할 경우 어떻게 처리하나요?

1. Separate Chaining

- 같은 주소로 해싱되어 충돌이 일어나는 Entry를 Linked List, Array 등으로 연결해서 저장하는 방식.
- 임의의 key에 해당하는 Entry를 저장할 때, 해시값이 가리키는 인덱스의 Linked List에 삽입

2. Open Addressing

- Separate Chaining과 달리 추가 공간을 사용하지 않고 충돌을 해결하는 방법.
- 충돌이 일어나면 정해진 Hash Table 공간에 다른 위치에 저장한다.
- 따라서, 해시값과 일치하는 인덱스(주소)에 저장된다는 보장이 없다.
- 즉, 충돌 발생 -> 정해진 규칙에 의해 다음 자리를 찾아 저장
- 이 규칙이라는 것에도 여러 가지 방법이 있다.

- 선형 탐색(Linear Probing)
- 가장 간단한 충돌 해결 방법으로, 충돌이 발생한 주소 바로 다음 위치에 저장/검색하는 방법이다.
- 이 방식에서 Hash Function은 일차 함수의 보폭으로 점프한다.
- 특정 영역에서 key가 몰리게 되면, 탐색 횟수가 늘어나 성능이 떨어진다. 비어있는 자리를 찾아야하니까.
- 이 때, 이차원 탐색(Quadratic Probing)과 더블 해싱(Double Hashing)으로 충돌을 피하면서, 군집 문제를 해결할 수 있음.
- 주의사항! 해시값과 인덱스가 일치한다는 보장이 없기 때문에, 데이터를 삭제할 때, 삭제된 데이터에 자리가 비어지게 되면 이후에 데이터를 검색할 때 문제가 발생한다. 왜? 해시값은 항상 같은 값을 반환하기 때문에 Linear Probing 처리되기 전 인덱스를 가리키기 때문에, 다른 곳에 저장되어버린 그 데이터가 없다고 판단해버리는 것이다.
- 이 문제를 해결하기 위해 삭제된 위치에 삭제되었다는 표시(값이든 뭐든)를 넣어준다. 그럼 원래 위치에 삭제 표시가 있으므로 다른 곳에 저장되어 있을 수도 있겠다고 생각하여 다시 검색할 수 있다.
- 이 때 끝까지 탐색이 진행되기 때문에 성능 저하가 발생할 수도 있다.

## Hash Table을 구현해보세요(Separate Chaining)

## Load Factor가 무엇인가요? 성능에 어떤 영향을 미치나요?

- Load Factor는 Hash Table이 "가득 찬 정도"를 나타낸다.
- 0.5는 절반이 차있다는 뜻.
- Separate Chaining과 Open Addressing에서 중요한 역할을 한다.

1. Separate Chaining

- Load Factor가 증가하면 하나의 주소에 저장된 Linked List의 평균 길이가 길어진다.
- 이로 인해 검색 성능이 저하될 수 있다.
- 보통 0.75를 임계 Load Factor로 잡는데, 이를 초과하면 Hash Table의 크기를 늘려서 리사이징하는 것이 일반적.

2. Open Addressing

- Load Factor가 증가하면 Hash Table 내의 사용 가능한 빈 슬롯이 줄어들게 된다.
- 이로 인해 새롭게 삽입하거나, 기존 항목 검색 시 충돌 횟수가 증가하게 되며 성능 저하로 이어진다.
- 보통 0.5, 0.6을 임계 Load Factor로 잡고, 리사이징을 한다.

## Hash Table에서 "동적 리사이징"이 무엇이며 언제 필요한가요?

- 동적 리사이징은 Table의 크기를 동적으로 조정하는 것.
- Separate Chaining에서는 Table을 순회하면서 기존의 Linked List의 길이에 2배인 새 Linked List를 만들고, 기존에 존재하던 값들을 순회하면서 새 것에 저장해준다.

# [알고리즘 | 기초]Recursion(재귀)

- 어떤 문제나 함수 등이 자신과 성격이 똑같지만 크기가 더 작은 문제를 하나 이상 포함하고 있을 때, 재귀적 구조를 가지고 있다고 한다.
- 보통 프로그래밍에서는 함수 내부에서 자신을 다시 호출하는 기능을 제공한다.
- 도미노를 하나씩 넘어뜨리는 것처럼, 작은 문제 하나를 해결하면 결국 큰 문제도 해결되는 것.

재귀는 두 가지 요소를 꼭 포함해야한다.

1. 경계 조건(Base Case)

- 재귀 알고리즘은 종료 조건이 필요하다. 이를 경계 조건이라고 부르며, 이 경우에는 알고리즘이 더 이상 재귀 호출을 하지 않고 바로 결과를 반환한다.

2. 재귀 호출(Recursive Case)

- 자신보다 작은 문제에 대해서 이 알고리즘이 작동한다면 , 자신에 대해서도 작동한다.

# [알고리즘 | 기초]Sorting(정렬)

## 선택 정렬(Selection Sort)

- 크기가 n인 배열에서 가장 작은 값을 선택해서 맨 앞 원소와 자리를 변경하는 것을 반복하는 알고리즘.
- 처음 맨 앞으로 옮긴 원소는 배열에서 가장 작은 원소이기 때문에 끝날 때까지 그 자리를 지킨다.
- 맨 앞의 뒤부터 또 다시 반복...
- 두 수를 비교해서 최소값을 찾는 작업을 몇 번 하는가에 따라서 시간 복잡도가 달라진다.
- 두 수를 비교하는 총 횟수는 (n-1)부터 점점 줄어들며 누적합이 되어서 n(n-1)/2 가 된다. 따라서 시간 복잡도는 O(n^2)

## 버블 정렬(Bubble Sort)

- 왼쪽부터 한 칸씩 이동하면서 이웃한 두 수를 비교해서 순서가 제대로 되어 있지 않으면 바꾸는 작업을 반복.
- 처음 이 과정을 반복하면 마지막 자리에 옮긴 원소는 정렬이 끝날 때까지 그 자리를 지킨다.
- 순회가 끝나기 전에 전부 정렬이 되었다면, 더 이상 정렬할 필요가 없으므로, 순회 도중 교환 여부를 체크해서 교환이 없으면 그대로 종료시키는 것으로 최적화가 가능하다.
- 두 수를 비교하는 총 횟수는 (n-1)부터 점점 줄어들며 누적합이 되어서 n(n-1)/2 가 된다. 따라서 시간 복잡도는 O(n^2)
- 단, 배열 안에 요소들이 거의 정렬되었거나 이미 정렬이 끝난 상태라면, Best의 경우에는 O(n)

## 삽입 정렬(Insertion Sort)

- 이미 정렬된 크기가 1인 배열에 하나씩 원소를 삽입하여 정렬된, 크기가 n인 배열을 만드는 알고리즘.
- 선택 정렬이나 버블 정렬보다 비교적 빠르다.
- 평균적으로는 O(n^2)

## 병합 정렬(Merge Sort)

- Divide and Conquer과 Recursion 알고리즘을 사용하는 정렬 방법이다. 더 작은 배열로 분할 후에 각 부분 배열을 정렬하고 병합하는 과정을 재귀적으로 반복한다.
- O(NlogN)

## 퀵 정렬

## 힙 정렬
