# 백엔드 시스템의 초석: 기초 자료구조 이해하기

## 백엔드 시스템 구석 구석에 자리잡고 있는 기초 자료구조

# 문제 해결 접근법

1. 문제 이해

- 문제를 잘 읽고(듣고), 정확하게 이해했는지 확인
- 문제와 관련된 모든 정보 기록(ex. "정렬된" 배열)
- 입력, 출력? 시간, 공간 복잡도, 메모리 사용량 제약? 체크
- 문제에서 가장 중요한 값은 무엇?
- 문제의 목표?

2. 구체적인 예제들

- 예제를 직접 손으로 그려보면서 제대로 이해했는지 확인
- 명확한 예제를 만들었나?
- 충분히 큰 예제로 만들어 졌는가?
- 너무 특별한(극단적인) 예제를 만들지 않도록 주의!

3. 계획 수립 및 알고리즘 설계(1) - 무식하게 풀기

- 보자마자 적용해볼만한 패턴이나 알고리즘이 떠오르지 않는다면, 가장 무식한 방법으로 문제 풀기(brute force)
- 문제 해결 패턴을 찾거나 알고리즘의 효율을 높이려고 미리 애쓰지 않도록 하기.

4. 계획 수립 및 알고리즘 설계(2) - 최적화

- 접근 방식을 되짚어 보며 "BUD" 방식을 최적화를 진행
- 병목 현상(Bottlenecks) : 코드 실행에서 특정 부분이 느리거나, 검색을 여러번 하는 것 처럼 반복 수행이 많은 경우
- 불필요한 작업(Unnecessary work) : 특정 값을 얻기 위한 연산이 필요한 작업인지 판단하고, 코드를 개선
- 중복되는 작업(Duplicated work) : 이미 한 번 진행했던 연산을 다시 하고 있지는 않은지 확인해보자. 대표적으로 같은 연산 결과를 사용하는 다른 연산이 있는 경우가 있겠다.

5. 검토하기

- 최적 설계한 알고리즘을 다시 한번 자세하게 검토

6. 알고리즘 구현

- 실제 코드를 작성
- 가독성, 모듈화를 고려해서 코드를 작성
- 모듈화를 할 수 있으면 처음부터 분리하는 것이 좋다.
- 오프라인 코딩 테스트라면 기능들을 나눠서 구현하고 쉬운 것부터 구현

7. 테스트

- 코드를 읽으면서 흐름과 로직의 문제를 검토.
- 연산 오류, 오버플로, 언더플로, null 참조 등 코드에서 실수하기 쉬운 부분 체크
- 테스트 실행 전에, 작은 테스트 케이스로 잘 동작하는지 확인
- 극단적인 값, 예외적인 값도 테스트.

# 문제 해결 접근법 - 기본

1. Two Pointers

- 배열이나 리스트 같은 선형 데이터에서 주로 사용
- 두 개의 포인터를 동시에 움직이면서 문제를 해결
- "한 쌍의 값이나 조건을 충족시키는 무언가를 찾는 문제"라면 적용 시도

2. Slide Window

- 배열이나 리스트 같은 일정한 크기의 구간(윈도우)를 움직이며 문제를 해결
- 윈도우의 크기가 고정일 수도 가변일 수도 있음
- 데이터 입력하거나 하위 집합을 찾는 경우에 유용하다.
- 일종의 "이동하는 뷰포트"와 같다.
- 가장 앞에 부분을 제거하고, 윈도우 바로 뒤의 값을 합하면 윈도우가 오른쪽으로 한칸 이동한 효과를 낼 수 있다.
- 덕분에 배열의 합을 구할 때 양 끝만 관리하면 됨.

3. Divided and Conquer

- 분할 정복이라고 부르며, 문제를 계속해서 잘게 쪼개서 재귀적으로 해결하는 방법이다.
- Binary Search가 대표적인 예시.

# 기초 자료구조 (배열, 연결 리스트,스택, 큐, 해쉬 테이블)의 특징과 장단점 그리고 활용 사례를 설명해보세요.

# 요구하는 자료구조를 직접 구현해보세요.

## Array & Linked List

### Linked List란 무엇인가요?

- Array

> Q : 왜 인덱스로 접근(랜덤 탐색)하면 O(1)이 되는거지?
> A : 물리적으로 주소가 연속되어 있기 때문이다.

> Q : 배열이 꽉 차있을 때 맨 뒤에 추가하면 어떻게 해야되나요?(정적 타입 언어)
> A : 기존 배열의 2배 되는 사이즈의 배열을 새로 생성한 뒤, 기존 값들을 복사해서 넣습니다. 그 후, 가득 찼던 배열을 참조하고 있던 것이 새롭게 만들어진 배열을 참조하도록 바꿔줍니다. 보통은 꽉 찬 배열 뒤에 삽입하지 않기 때문에 시간 복잡도를 O(1)이라고 함.

- Linked List

> Q : Linked List의 장점?
> A : 배열과 비교했을 떄, 삽입/삭제 연산에 효율적인 자료구조입니다. 따라서 삽입/삭제가 잦은 알고리즘에 사용하면 좋다. 또한, 원소가 추가될 때마다 공간을 할당 받아 비연속적인 메모리 공간에 추가합니다.(배열은 주소가 연속적)

> Q : 시간 복잡도?
> A : 접근, 검색은 O(n)이다. 순차적으로 노드를 따라가니까.
> A : 시작에 삽입은 O(1)이다. 가장 앞의 노드에 연결하니까. 배열은 뒤로 밀리기 때문에 O(n)인데, 얘는 한칸씩 뒤로 미룰 필요가 없기 때문. 헤드의 참조들만 바꾸면 된다.
> A : 중간, 마지막에 삽입은 O(n)이다. 삽입할 위치를 찾아야하니까.
> A : 시작을 삭제하는 경우에는 O(1). 헤드의 참조값을 두 번째 노드로 전환하면 되니까. 첫 번째였던 노드는 가비지 컬렉터에 의해 사라질 것.
> A : 중간, 끝을 삭제하는 경우에는 O(n)이다. 삭제할 위치를 찾아야하니까.

> Q : 끝에 삽입할 때 시간 복잡도 O(n)을 O(1)으로 개선할 수 없을까요?
> A : 헤드가 첫번째 값을 기억하고 있는 것 처럼, 마지막 노드의 값을 테일(tail)이 기억해두면 됩니다.

> Q : 끝을 삭제할 때 시간 복잡도 O(n)을 O(1)으로 개선할 수 없을까요?
> A : 테일(tail)이 아니라 테일이 보고 있는 노드의 직전 노드를 알아야함. 그러나 알 방법이 없다. 마지막 노드에 이전 노드를 참조하는 부분을 추가하면 이를 알 수 있음! 그 곳에 접근해서 다음 노드를 null로 바꾸면 되니까. 이게 Doubly Linked List!

# Stack

# 각 자료구조의 시간 복잡도와 공간 복잡도를 비교해보세요.

# 주어진 문제에 어떤 자료구조가 가장 적합할지 고민해보세요.

# 구현한 자료구조의 시간 복잡도를 Big O 표기법으로 측정해보세요.

# [아하!모먼트] 자료구조가 소프트웨어 성능에 어떠한 영향을 미치는가?
